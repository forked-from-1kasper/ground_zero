import GroundZero.Theorems.Equiv
import GroundZero.Theorems.Nat
import GroundZero.Types.Lost

open GroundZero GroundZero.Types
open GroundZero.Types.Equiv
open GroundZero.Theorems
open GroundZero.Proto

open GroundZero.Structures (dec prop contr)
open GroundZero.Types.Id (ap)

universe u v w

-- exercise 3.9

namespace ¬´3.9¬ª
  section
    variable {A : Type u} {H : prop A} {lem : LEM‚Çã‚ÇÅ}

    hott def lemTrue (x : A) : lem A H = Sum.inl x :=
    match lem A H with
    | Sum.inl y => ap Sum.inl (H y x)
    | Sum.inr œÜ => Empty.elim (œÜ x)

    hott def lemFalse (œÜ : ¬¨A) : lem A H = Sum.inr œÜ :=
    match lem A H with
    | Sum.inl x => Empty.elim (œÜ x)
    | Sum.inr œà => ap Sum.inr (Structures.notIsProp œà œÜ)
  end

  hott def Œ©elim (lem : LEM‚Çã‚ÇÅ u) : Prop u ‚Üí ùüê :=
  Œª w, Coproduct.elim (Œª _, true) (Œª _, false) (lem w.1 w.2)

  hott def Œ©intro : ùüê ‚Üí Prop :=
  Bool.elim ‚ü®ùüé, Structures.emptyIsProp‚ü© ‚ü®ùüè, Structures.unitIsProp‚ü©

  hott lemma propsetInhIsProp (A : Prop) : prop A.1 := A.2

  hott lemma Œ©linv (lem : LEM‚Çã‚ÇÅ) : Œ©elim lem ‚àò Œ©intro ~ idfun
  | false => ap (Coproduct.elim _ _) (lemFalse Empty.elim)
  | true  => ap (Coproduct.elim _ _) (lemTrue ‚òÖ)

  hott lemma Œ©rinv (lem : LEM‚Çã‚ÇÅ) : Œ©intro ‚àò Œ©elim lem ~ idfun :=
  begin
    intro w; apply Equiv.propset.Id; match lem w.1 w.2 with | Sum.inl x => _ | Sum.inr œÜ => _;

    transitivity; apply Id.map; apply Id.map (Bool.elim _ _); apply Id.map (Coproduct.elim _ _);
    apply lemTrue x; symmetry; apply ua; apply Structures.contrEquivUnit;
    fapply Sigma.mk; exact x; intro y; apply w.2;

    transitivity; apply Id.map; apply Id.map (Bool.elim _ _); apply Id.map (Coproduct.elim _ _);
    apply lemFalse œÜ; symmetry; apply ua; apply uninhabitedType; exact Empty.elim ‚àò œÜ
  end

  hott theorem lemImplPropEqvBool (lem : LEM‚Çã‚ÇÅ) : Prop u ‚âÉ ùüê :=
  ‚ü®Œ©elim lem, Qinv.toBiinv _ ‚ü®Œ©intro, (Œ©linv lem, Œ©rinv lem)‚ü©‚ü©
end ¬´3.9¬ª

-- exercise 3.10

namespace ¬´3.10¬ª
  open ¬´3.9¬ª

  inductive Resize (A : Type u) : Type (max u v)
  | intro : A ‚Üí Resize A

  hott def Resize.elim {A : Type u} : Resize A ‚Üí A
  | intro w => w

  hott theorem Resize.equiv (A : Type u) : A ‚âÉ Resize.{u, v} A :=
  ‚ü®Resize.intro, Qinv.toBiinv _ ‚ü®Resize.elim, (Œª (Resize.intro _), idp _, idp)‚ü©‚ü©

  hott lemma Resize.prop {A : Type u} (H : prop A) : prop (Resize.{u, v} A) :=
  Structures.propRespectsEquiv.{u, max u v} (Resize.equiv A) H

  hott def ResizeŒ© : Prop u ‚Üí Prop (max u v) :=
  Œª w, ‚ü®Resize.{u, v} w.1, Resize.prop w.2‚ü©

  hott lemma lemCumulativity (lem : LEM‚Çã‚ÇÅ (max u v)) : LEM‚Çã‚ÇÅ u :=
  Œª A H, match lem (Resize.{u, v} A) (Resize.prop H) with
  | Sum.inl x => Sum.inl (Resize.elim x)
  | Sum.inr œÜ => Sum.inr (œÜ ‚àò Resize.intro)

  hott corollary lemSucCumulativity : LEM‚Çã‚ÇÅ (u + 1) ‚Üí LEM‚Çã‚ÇÅ u :=
  lemCumulativity.{u, u + 1}

  hott lemma lemImplPropUniverseEqv (lem : LEM‚Çã‚ÇÅ (max u v)) : Prop u ‚âÉ Prop (max u v) :=
  Equiv.trans (lemImplPropEqvBool (lemCumulativity.{u, v} lem))
              (Equiv.symm (lemImplPropEqvBool lem))

  hott lemma resizeUniqLem1 (lem : LEM‚Çã‚ÇÅ (max u v)) : (lemImplPropUniverseEqv.{u, v} lem).1 ‚àò Œ©intro ~ ResizeŒ©.{u, v} ‚àò Œ©intro :=
  begin
    intro b; transitivity; apply ap Œ©intro; apply Œ©linv; apply Equiv.propset.Id;
    symmetry; apply ua; induction b using Bool.casesOn;
    { apply uninhabitedType; exact Empty.elim ‚àò Resize.elim };
    { apply Structures.contrEquivUnit; existsi Resize.intro ‚òÖ;
      intro (Resize.intro b); apply ap; apply Structures.unitIsProp }
  end

  hott lemma resizeUniqLem2 (lem : LEM‚Çã‚ÇÅ (max u v)) : (lemImplPropUniverseEqv.{u, v} lem).1 ~ ResizeŒ©.{u, v} :=
  begin
    intro w; transitivity; apply ap; symmetry; apply Œ©rinv (lemCumulativity.{u, v} lem);
    transitivity; apply resizeUniqLem1; apply ap ResizeŒ©; apply Œ©rinv
  end

  hott theorem lemImplResizing (lem : LEM‚Çã‚ÇÅ (max u v)) : biinv ResizeŒ© :=
  transport biinv (Theorems.funext (resizeUniqLem2.{u, v} lem)) (lemImplPropUniverseEqv lem).2

  hott corollary lemImplResizingSuc : LEM‚Çã‚ÇÅ (u + 1) ‚Üí biinv ResizeŒ©.{u, u + 1} :=
  lemImplResizing.{u, u + 1}
end ¬´3.10¬ª

-- exercise 3.11

namespace ¬´3.11¬ª
  open HITs.Interval (happly)
  open ua (negBoolEquiv)
  open HITs

  hott lemma negBoolNoFixPoint : Œ† (x : ùüê), not x ‚â† x
  | false => Œª p, Structures.ffNeqTt p‚Åª¬π
  | true  => Œª p, Structures.ffNeqTt p

  hott theorem WCInfDisproved : ¬¨(Œ† (A : Type), ‚à•A‚à• ‚Üí A) :=
  begin
    intro f;
    let p := ua negBoolEquiv;

    let Œ± := Œª u, ua.transportRule negBoolEquiv (f ùüê u);
    let Œ≤ := Œª u, ap (Œª w, transport (Œª A, A) p (f ùüê w))
                     (Merely.uniq u (transport (Œª A, ‚à•A‚à•) p‚Åª¬π u));
    let Œ≥ := (transportOverFunctor (Œª A, ‚à•A‚à•) (Œª A, A) (f ùüê) p)‚Åª¬π ‚¨ù apd f p;
    let e := Œª u, (Œ± u)‚Åª¬π ‚¨ù Œ≤ u ‚¨ù happly Œ≥ u;
  
    apply negBoolNoFixPoint; exact e (Merely.elem false)
  end

  hott lemma merelyImplDneg {A : Type u} : ‚à•A‚à• ‚Üí ¬¨¬¨A :=
  HITs.Merely.rec Structures.notIsProp (Œª x œÜ, œÜ x)

  -- Theorem 3.2.2
  hott corollary dnegInfDisproved : ¬¨(Œ† (A : Type), (¬¨¬¨A) ‚Üí A) :=
  Œª H, WCInfDisproved (Œª A, H A ‚àò merelyImplDneg)
end ¬´3.11¬ª

-- exercise 3.12

namespace ¬´3.12¬ª
  hott lemma implOfSum {A : Type u} {B : Type v} : (¬¨A) + B ‚Üí A ‚Üí B
  | Sum.inl œÜ => Empty.elim ‚àò œÜ
  | Sum.inr b => Œª _, b

  hott theorem WC (lem : LEM‚Çã‚ÇÅ u) : Œ† (A : Type u), ‚à•(‚à•A‚à• ‚Üí A)‚à• :=
  begin
    intro A; apply HITs.Merely.lift; apply implOfSum;
    match lem ‚à•A‚à• HITs.Merely.uniq with | Sum.inl x => _ | Sum.inr œÜ => _;
    apply HITs.Merely.lift; apply Sum.inr; assumption;
    apply HITs.Merely.elem; left; assumption
  end
end ¬´3.12¬ª

-- exercise 3.13

namespace ¬´3.13¬ª
  open Structures (hset)
  open ¬´3.11¬ª

  hott lemma LEMinfImplDNegInf (lem : LEM‚àû u) {A : Type u} : ‚à•A‚à• ‚Üí A :=
  match lem A with
  | Sum.inl a => Œª _, a
  | Sum.inr œÜ => Œª w, Empty.elim (@merelyImplDneg A w œÜ)

  -- see lemma 3.8.2
  hott theorem LEMinfImplCartesian (lem : LEM‚àû v) (A : Type u) (B : A ‚Üí Type v) :
    hset A ‚Üí (Œ† x, hset (B x)) ‚Üí (Œ† x, ‚à•B x‚à•) ‚Üí ‚à•Œ† x, B x‚à• :=
  Œª _ _ f, HITs.Merely.elem (Œª x, LEMinfImplDNegInf lem (f x))

  hott theorem LEMinfImplAC (lem : LEM‚àû (max v w)) {A : Type u} (B : A ‚Üí Type v) (Œ∑ : Œ† x, B x ‚Üí Type w) :
    hset A ‚Üí (Œ† x, hset (B x)) ‚Üí
             (Œ† x y, prop (Œ∑ x y)) ‚Üí
             (Œ† (x : A), ‚à•(Œ£ (y : B x), Œ∑ x y)‚à•) ‚Üí
            ‚à•(Œ£ (œÜ : Œ† x, B x), Œ† x, Œ∑ x (œÜ x))‚à• :=
  Œª _ _ _ f, HITs.Merely.elem ‚ü®Œª x, (LEMinfImplDNegInf lem (f x)).1,
                               Œª x, (LEMinfImplDNegInf lem (f x)).2‚ü©

  hott lemma LEMinfDual (lem : LEM‚àû v) {A : Type u} {B : A ‚Üí Type v} : ¬¨(Œ£ x, ¬¨B x) ‚Üí Œ† x, B x :=
  Œª œÜ x, match lem (B x) with
  | Sum.inl b => b
  | Sum.inr œà => Empty.elim (œÜ ‚ü®x, œà‚ü©)
end ¬´3.13¬ª

namespace ¬´3.14¬ª
  open HITs.Interval (happly)
  open ¬´3.11¬ª
  open ¬´3.9¬ª

  hott def dneg.intro {A : Type u} : A ‚Üí ¬¨¬¨A :=
  Œª x œÜ, œÜ x

  hott def dneg.rec (lem : LEM‚Çã‚ÇÅ v) {A : Type u} {B : Type v} : prop B ‚Üí (A ‚Üí B) ‚Üí (¬¨¬¨A ‚Üí B) :=
  Œª H f, Coproduct.elim (Œª b _, b) (Œª œÜ g, Empty.elim (g (œÜ ‚àò f))) (lem B H)

  hott def dneg.recŒ≤rule (lem : LEM‚Çã‚ÇÅ v) {A : Type u} {B : Type v} {H : prop B}
    {f : A ‚Üí B} (x : A) : dneg.rec lem H f (dneg.intro x) = f x :=
  H _ _

  hott def dnegImplMerely (lem : LEM‚Çã‚ÇÅ u) {A : Type u} : ¬¨¬¨A ‚Üí ‚à•A‚à• :=
  dneg.rec lem HITs.Merely.uniq HITs.Merely.elem

  hott def lemMerelyEqvDef (lem : LEM‚Çã‚ÇÅ u) {A : Type u} : ¬¨¬¨A ‚âÉ ‚à•A‚à• :=
  Structures.propEquivLemma Structures.notIsProp HITs.Merely.uniq (dnegImplMerely lem) merelyImplDneg
end ¬´3.14¬ª

-- exercise 3.19

namespace ¬´3.19¬ª
  variable {P : ‚Ñï ‚Üí Type u} (H : Œ† n, prop (P n)) (G : Œ† n, dec (P n))
  open GroundZero.HITs

  hott def BSA (n : ‚Ñï) : ‚Ñï ‚Üí ‚Ñï
  | Nat.zero   => n
  | Nat.succ m => Coproduct.elim (Œª _, n) (Œª _, BSA (Nat.succ n) m) (G n)

  hott def BS := BSA G Nat.zero

  hott lemma BSP (n m : ‚Ñï) : P (n + m) ‚Üí P (BSA G n m) :=
  begin
    intro h; induction m using Nat.casesOn;
    case zero   => { exact h };
    case succ m => { show P (Coproduct.elim _ _ _); induction G n using Sum.casesOn;
                     case inl p  => { exact p };
                     case inr np => { apply BSP (Nat.succ n) m;
                                      exact transport P (Nat.succPlus n m)‚Åª¬π h }; };
  end

  hott lemma minimality (n m k : ‚Ñï) : P k ‚Üí n ‚â§ k ‚Üí BSA G n m ‚â§ k :=
  begin
    intro pk h; induction m using Nat.casesOn;
    case zero   => { exact h };
    case succ m => { show Coproduct.elim _ _ _ ‚â§ _; induction G n using Sum.casesOn;
                     case inl p  => { exact h };
                     case inr np => { apply minimality (Nat.succ n) m k pk;
                                      apply Nat.le.neqSucc;
                                      { intro œâ; apply np; apply transport P;
                                        symmetry; apply ap Nat.pred œâ; exact pk };
                                      apply Nat.le.map; exact h } }
  end

  hott lemma minExists : (Œ£ n, P n) ‚Üí Œ£ n, P n √ó Œ† m, P m ‚Üí n ‚â§ m :=
  Œª w, ‚ü®BS G w.1, (BSP G Nat.zero w.1 (transport P (Nat.zeroPlus w.1)‚Åª¬π w.2),
                   Œª m h, minimality G Nat.zero w.1 m h (Nat.max.zeroLeft m))‚ü©

  hott lemma minUnique : prop (Œ£ n, P n √ó Œ† m, P m ‚Üí n ‚â§ m) :=
  Œª w‚ÇÅ w‚ÇÇ, Sigma.prod (Nat.le.asymm (w‚ÇÅ.2.2 w‚ÇÇ.1 w‚ÇÇ.2.1) (w‚ÇÇ.2.2 w‚ÇÅ.1 w‚ÇÅ.2.1))
                      (Structures.productProp (H _) (Structures.piProp
                        (Œª _, Structures.piProp (Œª _, Nat.le.prop _ _))) _ _)

  hott theorem elimMerelyDecPropFamily : ‚à•Œ£ n, P n‚à• ‚Üí Œ£ n, P n :=
  begin
    fapply Function.comp; exact (Œ£ n, P n √ó Œ† m, P m ‚Üí n ‚â§ m);
    intro w; existsi w.1; exact w.2.1; apply Function.comp;
    apply Merely.rec; apply minUnique H; exact idfun;
    apply Merely.lift; apply minExists G
  end

  hott lemma upperEstimate (n m : ‚Ñï) : BSA G n m ‚â§ n + m :=
  begin
    induction m using Nat.casesOn;
    case zero   => { apply Nat.max.refl };
    case succ m => { show Coproduct.elim _ _ _ ‚â§ _; induction G n using Sum.casesOn;
                     case inl p  => { apply Nat.le.addl Nat.zero; apply Nat.max.zeroLeft };
                     case inr np => { apply transport (_ ‚â§ ¬∑); apply Nat.succPlus;
                                      apply upperEstimate (Nat.succ n) m } }
  end

  hott lemma lowerEstimate (n m : ‚Ñï) : n ‚â§ BSA G n m :=
  begin
    induction m using Nat.casesOn;
    case zero   => { apply Nat.max.refl };
    case succ m => { show _ ‚â§ Coproduct.elim _ _ _; induction G n using Sum.casesOn;
                     case inl p  => { apply Nat.max.refl };
                     case inr np => { apply Nat.le.trans; apply Nat.le.succ;
                                      apply lowerEstimate (Nat.succ n) m } }
  end
end ¬´3.19¬ª

namespace ¬´3.23¬ª
  hott def choice {A : Type u} (G : dec A) : A ‚Üí Type u :=
  Œª x, Coproduct.elim (x = ¬∑) (Œª œÜ, Empty.elim (œÜ x)) G

  hott def decMerely {A : Type u} (G : dec A) : Type u :=
  Œ£ x, choice G x

  hott def decMerely.elem {A : Type u} (G : dec A) : A ‚Üí decMerely G :=
  begin
    intro x; induction G using Sum.casesOn;
    case inl y => { existsi y; apply idp };
    case inr œÜ => { apply Empty.elim (œÜ x) }
  end

  hott def decMerely.uniq {A : Type u} (G : dec A) : prop (decMerely G) :=
  begin
    induction G using Sum.casesOn;
    case inl _ => { intro w‚ÇÅ w‚ÇÇ; fapply Sigma.prod;
                    { transitivity; apply w‚ÇÅ.2; symmetry; apply w‚ÇÇ.2 };
                    { transitivity; apply transportCompositionRev;
                      apply Equiv.rewriteComp; symmetry;
                      apply Id.cancelInvComp } };
    case inr œÜ => { intro w‚ÇÅ w‚ÇÇ; apply Empty.elim (œÜ w‚ÇÅ.1) }
  end

  hott def decMerely.dec {A : Type u} (G : dec A) : dec (@decMerely A G) :=
  begin
    induction G using Sum.casesOn;
    case inl x => { left; existsi x; apply idp };
    case inr œÜ => { right; intro w; apply œÜ w.1 }
  end

  variable {P : ‚Ñï ‚Üí Type u} (G : Œ† n, dec (P n))
  open GroundZero.HITs
  open ¬´3.19¬ª

  hott theorem elimMerelyDecFamily : ‚à•Œ£ n, P n‚à• ‚Üí Œ£ n, P n :=
  begin
    fapply Function.comp; exact (Œ£ n, decMerely (G n));
    intro w; existsi w.1; exact w.2.1; apply Function.comp;
    apply elimMerelyDecPropFamily;
    { intro n; apply decMerely.uniq (G n) };
    { intro n; apply decMerely.dec (G n) };
    { apply Merely.lift; intro w; existsi w.1;
      apply decMerely.elem; exact w.2 }
  end
end ¬´3.23¬ª
