import GroundZero.Types.Product
import GroundZero.Theorems.Nat
import GroundZero.Types.Sigma

open GroundZero GroundZero.Types
open GroundZero.Types.Equiv
open GroundZero.Proto

open GroundZero.Structures (prop contr)

universe u v w k

-- exercise 1.1
hott def compAssoc {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type k}
  (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (h : Œ≥ ‚Üí Œ¥) : h ‚àò (g ‚àò f) = (h ‚àò g) ‚àò f :=
by reflexivity

-- exercise 1.2

hott def Product.rec' {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}
  (œÜ : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : Œ± √ó Œ≤ ‚Üí Œ≥ :=
Œª u, œÜ u.1 u.2

example {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}
  (œÜ : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (b : Œ≤) :
  Product.rec' œÜ (a, b) = œÜ a b :=
by reflexivity

hott def Sigma.rec' {Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {Œ≥ : Type w}
  (œÜ : Œ† x, Œ≤ x ‚Üí Œ≥) : (Œ£ x, Œ≤ x) ‚Üí Œ≥ :=
Œª u, œÜ u.1 u.2

example {Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {Œ≥ : Type w}
  (œÜ : Œ† x, Œ≤ x ‚Üí Œ≥) (a : Œ±) (b : Œ≤ a) :
  Sigma.rec' œÜ ‚ü®a, b‚ü© = œÜ a b :=
by reflexivity

-- exercise 1.3

hott def Product.ind' {Œ± : Type u} {Œ≤ : Type v} {œÄ : Œ± √ó Œ≤ ‚Üí Type w}
  (œÜ : Œ† a b, œÄ (a, b)) : Œ† x, œÄ x :=
Œª u, transport œÄ (Product.uniq u) (œÜ u.1 u.2)

example {Œ± : Type u} {Œ≤ : Type v} {œÄ : Œ± √ó Œ≤ ‚Üí Type w}
  (œÜ : Œ† a b, œÄ (a, b)) (a : Œ±) (b : Œ≤) : Product.ind' œÜ (a, b) = œÜ a b :=
by reflexivity

hott def Sigma.ind' {Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {œÄ : (Œ£ x, Œ≤ x) ‚Üí Type w}
  (œÜ : Œ† a b, œÄ ‚ü®a, b‚ü©) : Œ† x, œÄ x :=
Œª u, transport œÄ (Sigma.uniq u) (œÜ u.1 u.2)

example {Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {œÄ : (Œ£ x, Œ≤ x) ‚Üí Type w}
  (œÜ : Œ† a b, œÄ ‚ü®a, b‚ü©) (a : Œ±) (b : Œ≤ a) : Sigma.ind' œÜ ‚ü®a, b‚ü© = œÜ a b :=
by reflexivity

-- exercise 1.4

hott def Nat.iter {C : Type u} (c‚ÇÄ : C) (c‚Çõ : C ‚Üí C) : ‚Ñï ‚Üí C
| Nat.zero   => c‚ÇÄ
| Nat.succ n => c‚Çõ (iter c‚ÇÄ c‚Çõ n)

hott def grec {C : Type u} (c‚ÇÄ : C) (c‚Çõ : ‚Ñï ‚Üí C ‚Üí C) : ‚Ñï ‚Üí ‚Ñï √ó C :=
@Nat.iter (‚Ñï √ó C) (0, c‚ÇÄ) (Œª u, (u.1 + 1, c‚Çõ u.1 u.2))

hott def grec.stable {C : Type u} (c‚ÇÄ : C) (c‚Çõ : ‚Ñï ‚Üí C ‚Üí C) :
  Œ† n, (grec c‚ÇÄ c‚Çõ n).1 = n
| Nat.zero   => idp 0
| Nat.succ n => Id.map Nat.succ (stable c‚ÇÄ c‚Çõ n)

section
  variable {C : Type u} (c‚ÇÄ : C) (c‚Çõ : ‚Ñï ‚Üí C ‚Üí C)

  hott def Nat.rec' : ‚Ñï ‚Üí C := Prod.pr‚ÇÇ ‚àò grec c‚ÇÄ c‚Çõ

  hott def Nat.iterŒ≤‚ÇÅ : Nat.rec' c‚ÇÄ c‚Çõ 0 = c‚ÇÄ :=
  by reflexivity

  hott def Nat.iterŒ≤‚ÇÇ (n : ‚Ñï) : Nat.rec' c‚ÇÄ c‚Çõ (n + 1) = c‚Çõ n (Nat.rec' c‚ÇÄ c‚Çõ n) :=
  Id.map (Œª m, c‚Çõ m (Nat.rec' c‚ÇÄ c‚Çõ n)) (grec.stable c‚ÇÄ c‚Çõ n)
end

-- exercise 1.5

hott def Coproduct' (Œ± Œ≤ : Type u) :=
Œ£ (x : ùüê), Bool.elim Œ± Œ≤ x

namespace Coproduct'
  variable {Œ± Œ≤ : Type u}

  def inl {Œ± Œ≤ : Type u} (a : Œ±) : Coproduct' Œ± Œ≤ := ‚ü®false, a‚ü©
  def inr {Œ± Œ≤ : Type u} (b : Œ≤) : Coproduct' Œ± Œ≤ := ‚ü®true,  b‚ü©

  variable (œÄ : Coproduct' Œ± Œ≤ ‚Üí Type v) (u : Œ† a, œÄ (inl a)) (v : Œ† b, œÄ (inr b))

  hott def ind : Œ† x, œÄ x
  | ‚ü®false, a‚ü© => u a | ‚ü®true, b‚ü© => v b

  hott def indŒ≤‚ÇÅ (a : Œ±) : ind œÄ u v (inl a) = u a :=
  by reflexivity

  hott def indŒ≤‚ÇÇ (b : Œ≤) : ind œÄ u v (inr b) = v b :=
  by reflexivity
end Coproduct'

-- exercise 1.6

hott def Product' (Œ± Œ≤ : Type u) :=
Œ† (x : ùüê), Bool.elim Œ± Œ≤ x

namespace Product'
  variable {Œ± Œ≤ : Type u}

  def mk (a : Œ±) (b : Œ≤) : Product' Œ± Œ≤ :=
  (@Bool.casesOn (Bool.elim Œ± Œ≤) ¬∑ a b)

  def pr‚ÇÅ : Product' Œ± Œ≤ ‚Üí Œ± := Œª u, u false
  def pr‚ÇÇ : Product' Œ± Œ≤ ‚Üí Œ≤ := Œª u, u true

  def Œ∑ (x : Product' Œ± Œ≤) : mk (pr‚ÇÅ x) (pr‚ÇÇ x) = x :=
  begin apply Theorems.funext; intro b; induction b using Bool.casesOn <;> reflexivity end

  variable (œÄ : Product' Œ± Œ≤ ‚Üí Type v) (œÜ : Œ† a b, œÄ (mk a b))

  hott def ind : Œ† x, œÄ x :=
  Œª x, transport œÄ (Œ∑ x) (œÜ (pr‚ÇÅ x) (pr‚ÇÇ x))

  hott def indŒ≤ (a : Œ±) (b : Œ≤) : ind œÄ œÜ (mk a b) = œÜ a b :=
  begin
    transitivity; apply Id.map (transport œÄ ¬∑ (œÜ a b));
    transitivity; apply Id.map Theorems.funext; change _ = (Œª x, idp (mk a b x));
    apply Theorems.funext; intro b; induction b using Bool.casesOn <;> reflexivity;
    apply Theorems.funextId; reflexivity
  end
end Product'

-- exercise 1.7

hott def Ind :=
Œ† (A : Type u) (C : Œ† x y, x = y ‚Üí Type v),
  (Œ† x, C x x (idp x)) ‚Üí Œ† (x y : A) (p : x = y), C x y p

hott def Ind' :=
Œ† (A : Type u) (a : A) (C : Œ† x, a = x ‚Üí Type v),
  C a (idp a) ‚Üí Œ† (x : A) (p : a = x), C x p

-- note that œÜ involves ‚Äúmax u (v + 1)‚Äù
example (œÜ : Ind.{u, max u (v + 1)}) : Ind'.{u, v} :=
Œª A a C c x p, œÜ A (Œª x y p, Œ† (C : Œ† z, x = z ‚Üí Type v), C x (idp x) ‚Üí C y p)
  (Œª x C d, d) a x p C c

-- lemma 2.3.1
hott def Transport :=
Œ† (A : Type u) (P : A ‚Üí Type v) (a b : A) (p : a = b), P a ‚Üí P b

-- lemma 3.11.8
hott def SinglContr :=
Œ† (A : Type u) (a b : A) (p : a = b), @Id (singl a) ‚ü®a, idp a‚ü© ‚ü®b, p‚ü©

hott def Ind.transport (œÜ : Ind.{u, v}) : Transport.{u, v} :=
Œª A P, œÜ A (Œª x y p, P x ‚Üí P y) (Œª x d, d)

hott def Ind.singlContr (œÜ : Ind.{u, u}) : SinglContr.{u} :=
Œª A a b p, œÜ A (Œª x y p, @Id (singl x) ‚ü®x, idp x‚ü© ‚ü®y, p‚ü©) (Œª _, idp _) a b p

hott def Ind.based (œÜ : Ind.{u, u}) : Ind'.{u, u} :=
Œª A a C c x p, Ind.transport œÜ (singl a) (Œª d, C d.1 d.2)
  ‚ü®a, idp a‚ü© ‚ü®x, p‚ü© (Ind.singlContr œÜ A a x p) c

-- exercise 1.8

namespace Nat'
  def ind (C : ‚Ñï ‚Üí Type u) (c‚ÇÄ : C 0) (c‚Çõ : Œ† n, C n ‚Üí C (n + 1)) : Œ† n, C n
  | Nat.zero   => c‚ÇÄ
  | Nat.succ n => c‚Çõ n (ind C c‚ÇÄ c‚Çõ n)

  def rec {C : Type u} (c‚ÇÄ : C) (c‚Çõ : ‚Ñï ‚Üí C ‚Üí C) : ‚Ñï ‚Üí C :=
  ind (Œª _, C) c‚ÇÄ c‚Çõ

  def add : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  Œª n, rec n (Œª _, Nat.succ)

  def mult : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  Œª n, rec 0 (Œª _, add n)

  def exp : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  Œª n, rec 1 (Œª _, mult n)

  hott def addZero : Œ† n, add n 0 = n := idp

  hott def zeroAdd : Œ† n, add 0 n = n :=
  ind (Œª n, add 0 n = n) (idp 0) (Œª n p, Id.map Nat.succ p)

  hott def succAdd : Œ† n m, add (n + 1) m = add n m + 1 :=
  Œª n, ind (Œª m, add (n + 1) m = add n m + 1) (idp (n + 1)) (Œª m p, Id.map Nat.succ p)

  hott def addComm : Œ† n m, add n m = add m n :=
  Œª n, ind (Œª m, add n m = add m n) (zeroAdd n)‚Åª¬π
    (Œª m p, (Id.map Nat.succ p) ‚¨ù (succAdd m n)‚Åª¬π)

  hott def addAssoc : Œ† n m k, add n (add m k) = add (add n m) k :=
  Œª n m, ind (Œª k, add n (add m k) = add (add n m) k) (idp (add n m)) (Œª k p, Id.map Nat.succ p)

  hott def oneMul : Œ† n, mult 1 n = n :=
  ind (Œª n, mult 1 n = n) (idp 0) (Œª n p, (addComm 1 (mult 1 n)) ‚¨ù Id.map Nat.succ p)

  hott def succMul : Œ† n m, mult (n + 1) m = add m (mult n m) :=
  Œª n, ind (Œª m, mult (n + 1) m = add m (mult n m)) (idp 0) (Œª m p, calc
    mult (n + 1) (m + 1) = add n (mult (n + 1) m) + 1   : succAdd n (mult (n + 1) m)
                     ... = add n (add m (mult n m)) + 1 : Id.map (Œª k, add n k + 1) p
                     ... = add (add n m) (mult n m) + 1 : Id.map Nat.succ (addAssoc n m (mult n m))
                     ... = add (add m n) (mult n m) + 1 : Id.map (Œª k, add k (mult n m) + 1) (addComm n m)
                     ... = add m (add n (mult n m)) + 1 : Id.map Nat.succ (addAssoc m n (mult n m))‚Åª¬π
                     ... = add (m + 1) (mult n (m + 1)) : (succAdd m (mult n (m + 1)))‚Åª¬π)

  hott def mulOne : Œ† n, mult n 1 = n :=
  ind (Œª n, mult n 1 = n) (idp 0) (Œª n p,
    (succMul n 1) ‚¨ù (addComm 1 (mult n 1)) ‚¨ù Id.map Nat.succ p)

  hott def mulZero : Œ† n, mult n 0 = 0 := Œª _, idp 0

  hott def zeroMul : Œ† n, mult 0 n = 0 :=
  ind (Œª n, mult 0 n = 0) (idp 0) (Œª n p, zeroAdd (mult 0 n) ‚¨ù p)

  hott def mulComm : Œ† n m, mult n m = mult m n :=
  Œª n, ind (Œª m, mult n m = mult m n) (zeroMul n)‚Åª¬π
    (Œª m p, Id.map (add n) p ‚¨ù (succMul m n)‚Åª¬π)

  hott def mulDistrLeft : Œ† n m k, mult n (add m k) = add (mult n m) (mult n k) :=
  Œª n m, ind (Œª k, mult n (add m k) = add (mult n m) (mult n k)) (idp (mult n m)) (Œª k p, calc
      mult n (add m (k + 1)) = add n (add (mult n m) (mult n k)) : Id.map (add n) p
                         ... = add (add (mult n m) (mult n k)) n : addComm _ _
                         ... = add (mult n m) (add (mult n k) n) : (addAssoc _ _ _)‚Åª¬π
                         ... = add (mult n m) (mult n (k + 1))   : Id.map (add (mult n m)) (addComm _ _))

  hott def mulDistrRight : Œ† n m k, mult (add n m) k = add (mult n k) (mult m k) :=
  Œª n m k, calc mult (add n m) k = mult k (add n m)          : mulComm _ _
                             ... = add (mult k n) (mult k m) : mulDistrLeft _ _ _
                             ... = add (mult n k) (mult m k) : bimap add (mulComm _ _) (mulComm _ _)

  hott def mulAssoc : Œ† n m k, mult n (mult m k) = mult (mult n m) k :=
  Œª n m, ind (Œª k, mult n (mult m k) = mult (mult n m) k) (idp 0) (Œª k p, calc
    mult n (mult m (k + 1)) = add (mult n m) (mult n (mult m k)) : mulDistrLeft _ _ _
                        ... = add (mult n m) (mult (mult n m) k) : Id.map (add (mult n m)) p
                        ... = mult (mult n m) (k + 1)            : idp _)
end Nat'

-- exercise 1.9

def fin (n : ‚Ñï) : Type := Œ£ m, m + 1 ‚â§ n

hott def vin.fmax (n : ‚Ñï) : fin (n + 1) :=
‚ü®n, Theorems.Nat.max.refl (n + 1)‚ü©

-- exercise 1.10

namespace Nat'
  hott def iterate {Œ± : Type u} (f : Œ± ‚Üí Œ±) : ‚Ñï ‚Üí (Œ± ‚Üí Œ±) :=
  @rec (Œ± ‚Üí Œ±) idfun (Œª _ g, f ‚àò g)

  hott def ack : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  rec Nat.succ (Œª m œÜ n, iterate œÜ (n + 1) 1)

  example (n : ‚Ñï) : ack 0 n = n + 1 :=
  by reflexivity

  example (m : ‚Ñï) : ack (m + 1) 0 = ack m 1 :=
  by reflexivity

  example (m n : ‚Ñï) : ack (m + 1) (n + 1) = ack m (ack (m + 1) n) :=
  by reflexivity
end Nat'

-- exercise 1.11

example (Œ± : Type u) : (¬¨¬¨¬¨Œ±) ‚Üí (¬¨Œ±) :=
Œª œÜ x, œÜ (Œª œà, œà x)

-- exercise 1.12

example (Œ± : Type u) (Œ≤ : Type v) : Œ± ‚Üí (Œ≤ ‚Üí Œ±) :=
Œª a b, a

example (Œ± : Type u) : Œ± ‚Üí ¬¨¬¨Œ± :=
Œª a œÜ, œÜ a

example (Œ± : Type u) (Œ≤ : Type v) : (¬¨Œ±) + (¬¨Œ≤) ‚Üí ¬¨(Œ± √ó Œ≤) :=
Œª œÜ w, @Coproduct.elim (¬¨Œ±) (¬¨Œ≤) ùüé (Œª œà, œà w.1) (Œª œà, œà w.2) œÜ

-- exercise 1.13

example (Œ± : Type u) : ¬¨¬¨(Œ± + ¬¨Œ±) :=
Œª œÜ, œÜ (Coproduct.inr (Œª a, œÜ (Coproduct.inl a)))

-- exercise 1.14

/-
def f {Œ± : Type u} (x : Œ±) (p : x = x) : p = idp x :=
@Id.casesOn Œ± x (Œª y p, ???) x p (idp (idp x))
-/

-- exercise 1.15

hott def ¬´Indiscernibility of Identicals¬ª {A : Type u} (C : A ‚Üí Type v)
  {a b : A} (p : a = b) : C a ‚Üí C b :=
@Id.casesOn A a (Œª x p, C a ‚Üí C x) b p idfun

-- exercise 1.16

example : Œ† (i j : ‚Ñï), i + j = j + i :=
Theorems.Nat.comm
