import GroundZero.Types.Product
import GroundZero.Theorems.Nat
import GroundZero.Types.Sigma

open GroundZero GroundZero.Types
open GroundZero.Types.Id (ap)
open GroundZero.Types.Equiv
open GroundZero.Proto

open GroundZero.Structures (prop contr)

universe u v w k

-- exercise 1.1

hott exercise compAssoc {A : Type u} {B : Type v} {C : Type w} {D : Type k}
  (f : A ‚Üí B) (g : B ‚Üí C) (h : C ‚Üí D) : h ‚àò (g ‚àò f) = (h ‚àò g) ‚àò f :=
by reflexivity

-- exercise 1.2

hott definition Product.rec' {A : Type u} {B : Type v} {C : Type w}
  (œÜ : A ‚Üí B ‚Üí C) : A √ó B ‚Üí C :=
Œª u, œÜ u.1 u.2

hott example {A : Type u} {B : Type v} {C : Type w}
  (œÜ : A ‚Üí B ‚Üí C) (a : A) (b : B) : Product.rec' œÜ (a, b) = œÜ a b :=
by reflexivity

hott definition Sigma.rec' {A : Type u} {B : A ‚Üí Type v} {C : Type w}
  (œÜ : Œ† x, B x ‚Üí C) : (Œ£ x, B x) ‚Üí C :=
Œª u, œÜ u.1 u.2

hott example {A : Type u} {B : A ‚Üí Type v} {C : Type w}
  (œÜ : Œ† x, B x ‚Üí C) (a : A) (b : B a) : Sigma.rec' œÜ ‚ü®a, b‚ü© = œÜ a b :=
by reflexivity

-- exercise 1.3

hott definition Product.ind' {A : Type u} {B : Type v} {C : A √ó B ‚Üí Type w}
  (œÜ : Œ† a b, C (a, b)) : Œ† x, C x :=
Œª u, transport C (Product.uniq u) (œÜ u.1 u.2)

hott example {A : Type u} {B : Type v} {C : A √ó B ‚Üí Type w}
  (œÜ : Œ† a b, C (a, b)) (a : A) (b : B) : Product.ind' œÜ (a, b) = œÜ a b :=
by reflexivity

hott definition Sigma.ind' {A : Type u} {B : A ‚Üí Type v} {C : (Œ£ x, B x) ‚Üí Type w}
  (œÜ : Œ† a b, C ‚ü®a, b‚ü©) : Œ† x, C x :=
Œª u, transport C (Sigma.uniq u) (œÜ u.1 u.2)

hott example {A : Type u} {B : A ‚Üí Type v} {C : (Œ£ x, B x) ‚Üí Type w}
  (œÜ : Œ† a b, C ‚ü®a, b‚ü©) (a : A) (b : B a) : Sigma.ind' œÜ ‚ü®a, b‚ü© = œÜ a b :=
by reflexivity

-- exercise 1.4

hott definition Nat.iter {C : Type u} (c‚ÇÄ : C) (c‚Çõ : C ‚Üí C) : ‚Ñï ‚Üí C
| Nat.zero   => c‚ÇÄ
| Nat.succ n => c‚Çõ (iter c‚ÇÄ c‚Çõ n)

hott definition grec {C : Type u} (c‚ÇÄ : C) (c‚Çõ : ‚Ñï ‚Üí C ‚Üí C) : ‚Ñï ‚Üí ‚Ñï √ó C :=
@Nat.iter (‚Ñï √ó C) (0, c‚ÇÄ) (Œª u, (u.1 + 1, c‚Çõ u.1 u.2))

hott definition grec.stable {C : Type u} (c‚ÇÄ : C) (c‚Çõ : ‚Ñï ‚Üí C ‚Üí C) : Œ† n, (grec c‚ÇÄ c‚Çõ n).1 = n
| Nat.zero   => idp 0
| Nat.succ n => ap Nat.succ (stable c‚ÇÄ c‚Çõ n)

section
  variable {C : Type u} (c‚ÇÄ : C) (c‚Çõ : ‚Ñï ‚Üí C ‚Üí C)

  hott definition Nat.rec' : ‚Ñï ‚Üí C := Prod.pr‚ÇÇ ‚àò grec c‚ÇÄ c‚Çõ

  hott definition Nat.iterŒ≤‚ÇÅ : Nat.rec' c‚ÇÄ c‚Çõ 0 = c‚ÇÄ :=
  by reflexivity

  hott definition Nat.iterŒ≤‚ÇÇ (n : ‚Ñï) : Nat.rec' c‚ÇÄ c‚Çõ (n + 1) = c‚Çõ n (Nat.rec' c‚ÇÄ c‚Çõ n) :=
  ap (Œª m, c‚Çõ m (Nat.rec' c‚ÇÄ c‚Çõ n)) (grec.stable c‚ÇÄ c‚Çõ n)
end

-- exercise 1.5

hott definition Coproduct' (A B : Type u) :=
Œ£ (x : ùüê), Bool.elim A B x

namespace Coproduct'
  variable {A B : Type u}

  hott definition inl {A B : Type u} (a : A) : Coproduct' A B := ‚ü®false, a‚ü©
  hott definition inr {A B : Type u} (b : B) : Coproduct' A B := ‚ü®true,  b‚ü©

  variable (C : Coproduct' A B ‚Üí Type v) (u : Œ† a, C (inl a)) (v : Œ† b, C (inr b))

  hott definition ind : Œ† x, C x
  | ‚ü®false, a‚ü© => u a | ‚ü®true, b‚ü© => v b

  hott definition indŒ≤‚ÇÅ (a : A) : ind C u v (inl a) = u a :=
  by reflexivity

  hott definition indŒ≤‚ÇÇ (b : B) : ind C u v (inr b) = v b :=
  by reflexivity
end Coproduct'

-- exercise 1.6

hott definition Product' (A B : Type u) :=
Œ† (x : ùüê), Bool.elim A B x

namespace Product'
  variable {A B : Type u}

  hott definition mk (a : A) (b : B) : Product' A B :=
  (@Bool.casesOn (Bool.elim A B) ¬∑ a b)

  hott definition pr‚ÇÅ : Product' A B ‚Üí A := Œª u, u false
  hott definition pr‚ÇÇ : Product' A B ‚Üí B := Œª u, u true

  hott definition Œ∑ (x : Product' A B) : mk (pr‚ÇÅ x) (pr‚ÇÇ x) = x :=
  begin apply Theorems.funext; intro b; induction b using Bool.casesOn <;> reflexivity end

  variable (œÄ : Product' A B ‚Üí Type v) (œÜ : Œ† a b, œÄ (mk a b))

  hott definition ind : Œ† x, œÄ x :=
  Œª x, transport œÄ (Œ∑ x) (œÜ (pr‚ÇÅ x) (pr‚ÇÇ x))

  hott definition indŒ≤ (a : A) (b : B) : ind œÄ œÜ (mk a b) = œÜ a b :=
  begin
    transitivity; apply ap (transport œÄ ¬∑ (œÜ a b));
    transitivity; apply ap Theorems.funext; change _ = (Œª x, idp (mk a b x));
    apply Theorems.funext; intro b; induction b using Bool.casesOn <;> reflexivity;
    apply Theorems.funextId; reflexivity
  end
end Product'

-- exercise 1.7

hott definition Ind :=
Œ† (A : Type u) (C : Œ† x y, x = y ‚Üí Type v),
  (Œ† x, C x x (idp x)) ‚Üí Œ† (x y : A) (p : x = y), C x y p

hott definition Ind' :=
Œ† (A : Type u) (a : A) (C : Œ† x, a = x ‚Üí Type v),
  C a (idp a) ‚Üí Œ† (x : A) (p : a = x), C x p

-- note that œÜ involves ‚Äúmax u (v + 1)‚Äù
hott example (œÜ : Ind.{u, max u (v + 1)}) : Ind'.{u, v} :=
Œª A a C c x p, œÜ A (Œª x y p, Œ† (C : Œ† z, x = z ‚Üí Type v), C x (idp x) ‚Üí C y p)
  (Œª x C d, d) a x p C c

-- lemma 2.3.1
hott definition Transport :=
Œ† (A : Type u) (P : A ‚Üí Type v) (a b : A) (p : a = b), P a ‚Üí P b

-- lemma 3.11.8
hott definition SinglContr :=
Œ† (A : Type u) (a b : A) (p : a = b), @Id (singl a) ‚ü®a, idp a‚ü© ‚ü®b, p‚ü©

hott definition Ind.transport (œÜ : Ind.{u, v}) : Transport.{u, v} :=
Œª A P, œÜ A (Œª x y p, P x ‚Üí P y) (Œª x d, d)

hott definition Ind.singlContr (œÜ : Ind.{u, u}) : SinglContr.{u} :=
Œª A a b p, œÜ A (Œª x y p, @Id (singl x) ‚ü®x, idp x‚ü© ‚ü®y, p‚ü©) (Œª _, idp _) a b p

hott definition Ind.based (œÜ : Ind.{u, u}) : Ind'.{u, u} :=
Œª A a C c x p, Ind.transport œÜ (singl a) (Œª d, C d.1 d.2)
  ‚ü®a, idp a‚ü© ‚ü®x, p‚ü© (Ind.singlContr œÜ A a x p) c

-- exercise 1.8

namespace Nat'
  hott definition ind (C : ‚Ñï ‚Üí Type u) (c‚ÇÄ : C 0) (c‚Çõ : Œ† n, C n ‚Üí C (n + 1)) : Œ† n, C n
  | Nat.zero   => c‚ÇÄ
  | Nat.succ n => c‚Çõ n (ind C c‚ÇÄ c‚Çõ n)

  hott definition rec {C : Type u} (c‚ÇÄ : C) (c‚Çõ : ‚Ñï ‚Üí C ‚Üí C) : ‚Ñï ‚Üí C :=
  ind (Œª _, C) c‚ÇÄ c‚Çõ

  hott definition add : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  Œª n, rec n (Œª _, Nat.succ)

  hott definition mult : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  Œª n, rec 0 (Œª _, add n)

  hott definition exp : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  Œª n, rec 1 (Œª _, mult n)

  hott definition addZero : Œ† n, add n 0 = n := idp

  hott definition zeroAdd : Œ† n, add 0 n = n :=
  ind (Œª n, add 0 n = n) (idp 0) (Œª n p, ap Nat.succ p)

  hott definition succAdd : Œ† n m, add (n + 1) m = add n m + 1 :=
  Œª n, ind (Œª m, add (n + 1) m = add n m + 1) (idp (n + 1)) (Œª m p, ap Nat.succ p)

  hott definition addComm : Œ† n m, add n m = add m n :=
  Œª n, ind (Œª m, add n m = add m n) (zeroAdd n)‚Åª¬π
    (Œª m p, (ap Nat.succ p) ‚¨ù (succAdd m n)‚Åª¬π)

  hott definition addAssoc : Œ† n m k, add n (add m k) = add (add n m) k :=
  Œª n m, ind (Œª k, add n (add m k) = add (add n m) k) (idp (add n m)) (Œª k p, ap Nat.succ p)

  hott definition oneMul : Œ† n, mult 1 n = n :=
  ind (Œª n, mult 1 n = n) (idp 0) (Œª n p, (addComm 1 (mult 1 n)) ‚¨ù ap Nat.succ p)

  hott definition succMul : Œ† n m, mult (n + 1) m = add m (mult n m) :=
  Œª n, ind (Œª m, mult (n + 1) m = add m (mult n m)) (idp 0) (Œª m p, calc
    mult (n + 1) (m + 1) = add n (mult (n + 1) m) + 1   : succAdd n (mult (n + 1) m)
                     ... = add n (add m (mult n m)) + 1 : ap (Œª k, add n k + 1) p
                     ... = add (add n m) (mult n m) + 1 : ap Nat.succ (addAssoc n m (mult n m))
                     ... = add (add m n) (mult n m) + 1 : ap (Œª k, add k (mult n m) + 1) (addComm n m)
                     ... = add m (add n (mult n m)) + 1 : ap Nat.succ (addAssoc m n (mult n m))‚Åª¬π
                     ... = add (m + 1) (mult n (m + 1)) : (succAdd m (mult n (m + 1)))‚Åª¬π)

  hott definition mulOne : Œ† n, mult n 1 = n :=
  ind (Œª n, mult n 1 = n) (idp 0) (Œª n p,
    (succMul n 1) ‚¨ù (addComm 1 (mult n 1)) ‚¨ù ap Nat.succ p)

  hott definition mulZero : Œ† n, mult n 0 = 0 := Œª _, idp 0

  hott definition zeroMul : Œ† n, mult 0 n = 0 :=
  ind (Œª n, mult 0 n = 0) (idp 0) (Œª n p, zeroAdd (mult 0 n) ‚¨ù p)

  hott definition mulComm : Œ† n m, mult n m = mult m n :=
  Œª n, ind (Œª m, mult n m = mult m n) (zeroMul n)‚Åª¬π
    (Œª m p, ap (add n) p ‚¨ù (succMul m n)‚Åª¬π)

  hott definition mulDistrLeft : Œ† n m k, mult n (add m k) = add (mult n m) (mult n k) :=
  Œª n m, ind (Œª k, mult n (add m k) = add (mult n m) (mult n k)) (idp (mult n m)) (Œª k p, calc
      mult n (add m (k + 1)) = add n (add (mult n m) (mult n k)) : ap (add n) p
                         ... = add (add (mult n m) (mult n k)) n : addComm _ _
                         ... = add (mult n m) (add (mult n k) n) : (addAssoc _ _ _)‚Åª¬π
                         ... = add (mult n m) (mult n (k + 1))   : ap (add (mult n m)) (addComm _ _))

  hott definition mulDistrRight : Œ† n m k, mult (add n m) k = add (mult n k) (mult m k) :=
  Œª n m k, calc mult (add n m) k = mult k (add n m)          : mulComm _ _
                             ... = add (mult k n) (mult k m) : mulDistrLeft _ _ _
                             ... = add (mult n k) (mult m k) : bimap add (mulComm _ _) (mulComm _ _)

  hott definition mulAssoc : Œ† n m k, mult n (mult m k) = mult (mult n m) k :=
  Œª n m, ind (Œª k, mult n (mult m k) = mult (mult n m) k) (idp 0) (Œª k p, calc
    mult n (mult m (k + 1)) = add (mult n m) (mult n (mult m k)) : mulDistrLeft _ _ _
                        ... = add (mult n m) (mult (mult n m) k) : ap (add (mult n m)) p
                        ... = mult (mult n m) (k + 1)            : idp _)
end Nat'

-- exercise 1.9

hott definition fin (n : ‚Ñï) : Type := Œ£ m, m + 1 ‚â§ n

hott definition fin.fmax (n : ‚Ñï) : fin (n + 1) :=
‚ü®n, Theorems.Nat.max.refl (n + 1)‚ü©

-- exercise 1.10

namespace Nat'
  hott definition iterate {A : Type u} (f : A ‚Üí A) : ‚Ñï ‚Üí (A ‚Üí A) :=
  @rec (A ‚Üí A) idfun (Œª _ g, f ‚àò g)

  hott definition ack : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  rec Nat.succ (Œª m œÜ n, iterate œÜ (n + 1) 1)

  hott example (n : ‚Ñï) : ack 0 n = n + 1 :=
  by reflexivity

  hott example (m : ‚Ñï) : ack (m + 1) 0 = ack m 1 :=
  by reflexivity

  hott example (m n : ‚Ñï) : ack (m + 1) (n + 1) = ack m (ack (m + 1) n) :=
  by reflexivity
end Nat'

-- exercise 1.11

hott example (A : Type u) : (¬¨¬¨¬¨A) ‚Üí (¬¨A) :=
Œª œÜ x, œÜ (Œª œà, œà x)

-- exercise 1.12

hott example (A : Type u) (B : Type v) : A ‚Üí (B ‚Üí A) :=
Œª a b, a

hott example (A : Type u) : A ‚Üí ¬¨¬¨A :=
Œª a œÜ, œÜ a

hott example (A : Type u) (B : Type v) : (¬¨A) + (¬¨B) ‚Üí ¬¨(A √ó B) :=
Œª œÜ w, @Coproduct.elim (¬¨A) (¬¨B) ùüé (Œª œà, œà w.1) (Œª œà, œà w.2) œÜ

-- exercise 1.13

hott example (A : Type u) : ¬¨¬¨(A + ¬¨A) :=
Œª œÜ, œÜ (Coproduct.inr (Œª a, œÜ (Coproduct.inl a)))

-- exercise 1.14

/-
hott definition f {A : Type u} (x : A) (p : x = x) : p = idp x :=
@Id.casesOn A x (Œª y p, ???) x p (idp (idp x))
-/

-- exercise 1.15

hott definition ¬´Indiscernibility of Identicals¬ª {A : Type u} (C : A ‚Üí Type v)
  {a b : A} (p : a = b) : C a ‚Üí C b :=
@Id.casesOn A a (Œª x p, C a ‚Üí C x) b p idfun

-- exercise 1.16

hott example : Œ† (i j : ‚Ñï), i + j = j + i :=
Theorems.Nat.comm
